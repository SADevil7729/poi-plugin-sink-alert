"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unionSorted = exports.inplaceSortBy = exports.sortBy = exports.projectorToComparator = exports.flipComparator = exports.chainComparators = exports.generalComparator = exports.scan = exports.insertAt = exports.modifyArray = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/*
   Array-related functions
 */
// "modifyArray(index,f)(xs)" keeps "xs" intact and returns a new array
// whose element on "index" is modified by feeding original value to "f".
// if "index" is out of range, "xs" itself is returned.
var modifyArray = function modifyArray(index, f) {
  if (typeof index !== 'number') console.error('index is not a number');
  if (typeof f !== 'function') console.error('modifier is not a function');
  return function (xs) {
    if (index < 0 || index >= xs.length) return xs;
    var v = xs[index];
    var newV = f(v);

    if (v !== newV) {
      var ys = _toConsumableArray(xs);

      ys[index] = newV;
      return ys;
    } else {
      return xs;
    }
  };
}; // insert a value at `ind` of an Array (functionally)


exports.modifyArray = modifyArray;

var insertAt = function insertAt(ind, val) {
  return function (xs) {
    return _toConsumableArray(xs.slice(0, ind)).concat([val], _toConsumableArray(xs.slice(ind, xs.length)));
  };
};

exports.insertAt = insertAt;

var scan = function scan(xs, acc, zero) {
  var ys = new Array(xs.length + 1);
  ys[0] = zero;

  for (var i = 0; i < xs.length; ++i) {
    ys[i + 1] = acc(ys[i], xs[i]);
  }

  return ys;
};
/*

   the functions in next section deals with things related to Array.prototype.sort

   terms:

   - comparator: a function that accepts two arguments and can be used as
     the argument to Array.prototype.sort

   - projector: a function that projects an Array element into a value
     for the purpose of sorting

 */

/*

   a comparator that works on any value that supports
   `===`, `>` and `<`.

   Note that it's assumed that `!(x === y) && !(x < y) && !(x > y)`
   suggests equality.

 */

/* eslint-disable indent */


exports.scan = scan;

var generalComparator = function generalComparator(x, y) {
  return x === y ? 0 : x < y ? -1 : x > y ? 1 : 0;
};
/* eslint-enable indent */
// composing multiple comparators into one by
// trying comparators **from left to right**, and return first non-zero value.
// if no comparator is provided or all comparator has return 0
// the resulting comparator returns 0 as well.


exports.generalComparator = generalComparator;

var chainComparators = function chainComparators() {
  for (var _len = arguments.length, cmps = new Array(_len), _key = 0; _key < _len; _key++) {
    cmps[_key] = arguments[_key];
  }

  return function (x, y) {
    // using for loop so we have a convenient way of short-cutting
    for (var i = 0; i < cmps.length; ++i) {
      var result = cmps[i](x, y);
      if (result !== 0) return result;
    }

    return 0;
  };
};

exports.chainComparators = chainComparators;

var flipComparator = function flipComparator(cmp) {
  return function (x, y) {
    return cmp(y, x);
  };
}; // create a comparator
// assuming the given projector projects a comparable value


exports.flipComparator = flipComparator;

var projectorToComparator = function projectorToComparator(prj) {
  return function (x, y) {
    return (// yes this is a precomposition, we could have used
      // `precompose` function, but we know the arity of comparator
      // is always 2, and don't realy need to use a general version
      generalComparator(prj(x), prj(y))
    );
  };
};

exports.projectorToComparator = projectorToComparator;

var sortBy = function sortBy() {
  var cmp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generalComparator;
  return function (xs) {
    return _toConsumableArray(xs).sort(cmp);
  };
};

exports.sortBy = sortBy;

var inplaceSortBy = function inplaceSortBy() {
  var cmp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generalComparator;
  return function (xs) {
    return xs.sort(cmp);
  };
}; // union 2 sorted arrays
// TODO use term 'merge', as `union` might suggest dedup.


exports.inplaceSortBy = inplaceSortBy;

var unionSorted = function unionSorted() {
  var cmp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generalComparator;
  return function (xs, ys) {
    var zs = [];
    var xInd = 0;
    var yInd = 0;

    for (;
    /* NOOP */
    xInd < xs.length && yInd < ys.length;)
    /* NOOP */
    {
      var cmpResult = cmp(xs[xInd], ys[yInd]);

      if (cmpResult <= 0) {
        zs.push(xs[xInd]);
        ++xInd;
      } else {
        zs.push(ys[yInd]);
        ++yInd;
      }
    }

    return zs.concat(xInd < xs.length ? xs.slice(xInd) : ys.slice(yInd));
  };
};

exports.unionSorted = unionSorted;