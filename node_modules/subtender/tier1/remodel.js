"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shipRemodelInfoBuilder = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _base = require("../base");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// remodelComparator(a,b) compares a and b and tries to put early forms in front.
// here both a and b are values of $ships.
var remodelComparator = (0, _base.chainComparators)( // 1: compare sort_id
function (a, b) {
  return a.api_sort_id % 10 - b.api_sort_id % 10;
}, // 2: compare sortno
function (a, b) {
  return a.api_sortno - b.api_sortno;
}, // 3: compare ship id
function (a, b) {
  return a.api_id - b.api_id;
});

var shipRemodelInfoBuilder = function shipRemodelInfoBuilder($ships) {
  var mstObjs = _lodash.default.values($ships).filter(function (x) {
    return x.api_id <= 1500;
  }); // master ids of all non-abyssal ships


  var mstIds = mstObjs.map(function (x) {
    return x.api_id;
  });

  var groupped = _lodash.default.groupBy(mstObjs, function (x) {
    return x.api_yomi;
  }); // set of masterIds that has some other ship pointing to it (through remodelling)


  var afterMstIdSet = new Set(); // key: mstId, value: Set of mstId

  var remodelGraph = new Map(); // traverse all remodels

  mstIds.map(function (mstId) {
    var $ship = $ships[mstId];
    var afterMstId = Number($ship.api_aftershipid);

    if (afterMstId !== 0) {
      afterMstIdSet.add(afterMstId);

      if (remodelGraph.has(mstId)) {
        remodelGraph.get(mstId).add(afterMstId);
      } else {
        var s = new Set();
        s.add(afterMstId);
        remodelGraph.set(mstId, s);
      }
    }
  });

  var mstIdRemodelComparator = function mstIdRemodelComparator(mstIdA, mstIdB) {
    return remodelComparator($ships[mstIdA], $ships[mstIdB]);
  };

  var inplaceSortMstIdsByRemodel = (0, _base.inplaceSortBy)(mstIdRemodelComparator);
  /*
     An Array whose elements are Arrays of mstIds.
     mstIds that are in the same Array are considered belonging to the same remodel cluster.
     Note that this step is just to group mstIds, we'll further process each group individually.
   */

  var remodelClusters = [];

  _lodash.default.toPairs(groupped).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        _yomi = _ref2[0],
        vals = _ref2[1];

    remodelClusters.push(vals.map(function (x) {
      return x.api_id;
    }));
  });

  var remodelChains = {};
  var originMstIdOf = {};

  _lodash.default.forEach(remodelClusters, function (mstIdCluster) {
    /*
       In most cases this correctly finds the original ship.
        Note that we are assuming there is at most one ship in each cluster
       that has no in-degree, which should be a safe one.
     */
    var originMstId = mstIdCluster.find(function (mstId) {
      return !afterMstIdSet.has(mstId);
    });

    if (!originMstId) {
      // mstIdCluster must be non-empty to have this element in the first place.
      var _mstIdCluster = _slicedToArray(mstIdCluster, 1);

      originMstId = _mstIdCluster[0];

      // sorting is unnecessary as we just want to find the minimum
      for (var i = 1; i < mstIdCluster.length; ++i) {
        var curMstId = mstIdCluster[i];

        if (mstIdRemodelComparator(originMstId, curMstId) > 0) {
          originMstId = curMstId;
        }
      }
    }

    mstIdCluster.forEach(function (mstId) {
      originMstIdOf[mstId] = originMstId;
    });
    var visited = new Set();
    var depClusters = [];

    var searchRemodels = function searchRemodels(mstId, depth) {
      if (visited.has(mstId)) {
        return;
      }

      visited.add(mstId);

      if (typeof depClusters[depth] === 'undefined') {
        depClusters[depth] = [mstId];
      } else {
        depClusters[depth].push(mstId);
      }

      if (remodelGraph.has(mstId)) {
        remodelGraph.get(mstId).forEach(function (afterMstId) {
          return searchRemodels(afterMstId, depth + 1);
        });
      }
    };

    searchRemodels(originMstId, 0); // if there is ever more than one element in one depth
    // this sorting step should make a reasonable decision.

    depClusters.forEach(function (xs) {
      return inplaceSortMstIdsByRemodel(xs);
    });

    var remodelChain = _lodash.default.compact(_lodash.default.flatten(depClusters));

    remodelChains[originMstId] = remodelChain; // last round of sanity check, if anything in the cluster is unreachable,
    // this part should signal it.

    var unreachableMstIds = mstIdCluster.filter(function (mstId) {
      return !visited.has(mstId);
    });

    if (unreachableMstIds.length > 0) {
      console.warn("Unreachable from originMstId=".concat(originMstId, ": ").concat(unreachableMstIds, ", those will be ignored from remodelChains data."));
    }
  });

  return {
    remodelChains: remodelChains,
    originMstIdOf: originMstIdOf
  };
};

exports.shipRemodelInfoBuilder = shipRemodelInfoBuilder;