"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SortedMap = void 0;

var _arrayOps = require("./array-ops");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var defaultSmContext = {
  elementToKey: function elementToKey(v) {
    return v.key;
  },
  compareKey: _arrayOps.generalComparator
  /*
     returns `null` only when the given SortedMap (Array) is empty,
  
     otherwise:
  
     - returns the index where 'key' is expected.
     - it's guaranteed that in this case the return value is always in range
     - if one wishes to insert a value, the insertion point could be before or
       after the index returned by this function, one should compare key with
       the element under index to tell:
  
       - if key > element.key, insertion point is right after the element
       - if key < element.key, insertion point is right before the element
  
  */

};

var locate = function locate(smContext) {
  return function (key) {
    return function (xs) {
      if (xs.length === 0) return null;
      var elementToKey = smContext.elementToKey,
          compareKey = smContext.compareKey; // INVARIANT: l <= r

      var find = function find(l, r) {
        if (l === r) return l; // now that the range contains at least 2 elements,
        // r > mid must hold.

        var mid = Math.floor((l + r) / 2);
        var cmpResult = compareKey(elementToKey(xs[mid]), key);

        if (cmpResult === 0) {
          // xs[mid].key === key
          return mid;
        }

        if (cmpResult < 0) {
          // xs[mid].key < key
          if (mid + 1 <= r) return find(mid + 1, r);
          /*
             mid+1 > r ==> mid >= r
             which contradicts the fact that r > mid
           */

          throw new Error('unreachable: mid+1 > r');
        } else {
          // xs[mid].key > key
          if (l <= mid - 1) return find(l, mid - 1);
          /*
             - l > mid-1 ==> l >= mid
             - l > mid is impossible
             - l === mid
              now that l === r is impossible,
             it must be the case where l+1 === r
           */

          return mid;
        }
      };

      return find(0, xs.length - 1);
    };
  };
};
/*
   modify(<smContext>)(<key>,<modifier>)(<SortedMap>) => SortedMap

   modifies the SortedMap as if we are using modifyObject on an Object.

   - smContext: {elementToKey, compareKey} (see comment on top)

   - modifier is called like: `modifier(<current val>, <key>, <isValAssigned>)`

     - <current val> is the current element in Array
       (`undefined` if it's a fresh place)
     - <isValAssigned>: whether the value is assigned. originally this is to
       keep API consistent with that of modifyObject, but since
       we have the assumption that SortedMap can't have `undefined` members,
       one could just test <current val> for getting the same info.

   - it's very important that modifier must either return `undefined` or return
     a value `val` which satisfies:

     `compareKey(elementToKey(val), key) === 0`

     otherwise SortedMap's properties will break.

   - modify **does not** provide any checks to ensure the key is preserved,
     but one can have their modifier decorated by SortedMap.guardModifier,
     which checks for this key-preseving property if the return value is not 'undefined'.

 */


var modify = function modify() {
  var smContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSmContext;
  return function (key, modifier) {
    return function (xs) {
      var elementToKey = smContext.elementToKey,
          compareKey = smContext.compareKey;

      if (xs.length === 0) {
        var _isValAssigned = false;

        var _newVal = modifier(undefined, key, _isValAssigned);

        if (typeof _newVal !== 'undefined') {
          return (0, _arrayOps.insertAt)(0, _newVal)(xs);
        } else {
          return xs;
        }
      }

      var ind = locate(smContext)(key)(xs);
      var cmpResult = compareKey(elementToKey(xs[ind]), key);
      var isValAssigned = cmpResult === 0;

      if (isValAssigned) {
        var val = xs[ind];

        var _newVal2 = modifier(val, key, isValAssigned);

        if (typeof _newVal2 === 'undefined') {
          return _toConsumableArray(xs.slice(0, ind)).concat(_toConsumableArray(xs.slice(ind + 1, xs.length)));
        } else {
          if (val === _newVal2) return xs;

          var ys = _toConsumableArray(xs);

          ys[ind] = _newVal2;
          return ys;
        }
      }

      var newVal = modifier(undefined, key, isValAssigned);
      if (typeof newVal === 'undefined') return xs;

      if (cmpResult < 0) {
        // xs[ind].key < key
        return (0, _arrayOps.insertAt)(ind + 1, newVal)(xs);
      } else {
        return (0, _arrayOps.insertAt)(ind, newVal)(xs);
      }
    };
  };
};

var find = function find() {
  var smContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSmContext;
  return function (key) {
    return function (xs) {
      if (xs.length === 0) return undefined;
      var ind = locate(smContext)(key)(xs);
      var elementToKey = smContext.elementToKey,
          compareKey = smContext.compareKey;
      var cmpResult = compareKey(elementToKey(xs[ind]), key);
      return cmpResult === 0 ? xs[ind] : undefined;
    };
  };
};
/*
   decorate a modifier to check for key-preserving property
 */


var guardModifier = function guardModifier() {
  var smContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSmContext;
  var elementToKey = smContext.elementToKey,
      compareKey = smContext.compareKey;
  return function (modifier) {
    return function (val, key, isValAssigned) {
      var newVal = modifier(val, key, isValAssigned);
      if (typeof newVal === 'undefined') return newVal;

      if (compareKey(elementToKey(newVal), key) !== 0) {
        console.error("invariant violated: modifier have changed a key");
        return val;
      } else {
        return newVal;
      }
    };
  };
};

var SortedMap = function SortedMap() {
  _classCallCheck(this, SortedMap);
};

exports.SortedMap = SortedMap;
Object.defineProperty(SortedMap, "defaultContext", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: defaultSmContext
});
Object.defineProperty(SortedMap, "modify", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: modify
});
Object.defineProperty(SortedMap, "find", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: find
});
Object.defineProperty(SortedMap, "guardModifier", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: guardModifier
});
Object.defineProperty(SortedMap, "withContext", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: function value(smContext) {
    var _class, _temp;

    return _temp = _class = function SortedMapWithContext() {
      _classCallCheck(this, SortedMapWithContext);
    }, Object.defineProperty(_class, "context", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: smContext
    }), Object.defineProperty(_class, "modify", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: modify(smContext)
    }), Object.defineProperty(_class, "find", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: find(smContext)
    }), Object.defineProperty(_class, "guardModifier", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: guardModifier(smContext)
    }), _temp;
  }
});