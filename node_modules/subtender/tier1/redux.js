"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mkSimpleReducer = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*

   make a simple reducer that accepts only a "Modify" action.

   - a "Modify" action has the shape:

     - type: `modifyActionType`
     - modifier: a function that takes the whole state and produces another

   optionally you can give `readyActionType`, which must be a non-empty string,
   which creates a different kind of reducer that, in addition to
   have the initial state as specified, will have a "ready" property of
   bool type.

   this kind of reducer initially accepts only a "Ready" action:

   - a "Ready" action has the shape:

     - type: `readyActionType`
     - (optional) newState: a state to replace the whole state

     (note: when `newState` is missing or is `undefined`, the initial state will be used)

   this action will set "ready" property to "true" automatically.
   and only accepts "Modify" action (exactly as described above) when "ready" property
   is set to true.

   note that your modifier has access to the "ready" property, so your "Modify"
   action may set a reducer state to "not-ready", but only "Ready" action
   can set a reducer to back to ready state.

   it's recommended that you should give `modifyActionType` and `readyActionType`
   as string literals, since a string literal has a better chance of being interned
   than those generated at runtime.

   see testcases in ../../test/tier1/redux/mk-simple-reducer.js for examples

 */
var mkSimpleReducer = function mkSimpleReducer(
/*
   either:
   - it's a function, which will be called without
     argument when it needs a initial state
   - it's an Object, which will be used as initial state
 */
initStateValOrThunk, modifyActionType) {
  var readyActionType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var getInitState = typeof initStateValOrThunk === 'function' ? initStateValOrThunk : function () {
    return initStateValOrThunk;
  };

  var defaultReducerImpl = function defaultReducerImpl() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getInitState();
    var action = arguments.length > 1 ? arguments[1] : undefined;

    if (action.type === modifyActionType) {
      var modifier = action.modifier;
      return modifier(state);
    }

    return state;
  };

  if (!readyActionType) {
    return defaultReducerImpl;
  } else {
    if (typeof readyActionType !== 'string') throw new Error('expecting readyActionType to be non-empty string');

    var getInitStateWithReady = function getInitStateWithReady() {
      return _objectSpread({}, getInitState(), {
        ready: false
      });
    };

    return function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getInitStateWithReady();
      var action = arguments.length > 1 ? arguments[1] : undefined;

      if (action.type === readyActionType) {
        var newState = action.newState;
        return _objectSpread({}, typeof newState !== 'undefined' ? newState : getInitStateWithReady(), {
          ready: true
        });
      }

      if (!state.ready) return state;
      return defaultReducerImpl(state, action);
    };
  }
};

exports.mkSimpleReducer = mkSimpleReducer;